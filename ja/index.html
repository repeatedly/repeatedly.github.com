
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Go ahead!</title>
  <meta name="author" content="Masahiro Nakagawa">

  
  <meta name="description" content="RubyKaigi 2014でServerEngineについて発表してきました． 最初はFluentdで発表しようかと思ったんですが，別の有用なプロジェクトの話もそろそろした方がいいかな，ということでServerEngineにしました． @sonotsさんがFluentdの発表をしてくれたので， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://repeatedly.github.com/ja">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Go ahead!" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Go ahead!</a></h1>
  
    <h2>Memoization for Everything</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:repeatedly.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  


  
<ul class="main-navigation">
  <li><a href="/ja/archives">Archives</a></li>
  <li><a href="/">English</a></li>
</ul>

  

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ja/2014/09/serverengine-at-rubykaigi-2014/">ServerEngine at RubyKaigi 2014</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-22T00:03:00+09:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2014</time>
        
         | <a href="/ja/2014/09/serverengine-at-rubykaigi-2014/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://rubykaigi.org/2014">RubyKaigi 2014</a>で<a href="http://rubykaigi.org/2014/presentation/S-MasahiroNakagawa">ServerEngineについて発表</a>してきました．</p>

<p>最初は<a href="http://www.fluentd.org/">Fluentd</a>で発表しようかと思ったんですが，別の有用なプロジェクトの話もそろそろした方がいいかな，ということでServerEngineにしました． <a href="http://blog.livedoor.jp/sonots/archives/40303560.html">@sonotsさんがFluentdの発表をしてくれた</a>ので，被らなくて良かった…</p>

<p><img src="/images/rubykaigi2014_serverengine_pic.jpg" width="425" title="&#34;RubyKaigi 2014: ServerEngine&#34;" alt="&#34;RubyKaigi 2014: ServerEngine&#34;">
画像は<a href="https://twitter.com/gihyoreport/status/512867195504701440/photo/1">技評さんから</a>．</p>

<p>以下がスライドです．書いてないことも発表では色々と話したので，動画が公開されればそれとセットで見た方が良いです．</p>

<iframe src="//www.slideshare.net/slideshow/embed_code/39292931" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe>


<p> <div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/treasure-data/rubykaigi-2014-serverengine" title="RubyKaigi 2014: ServerEngine" target="_blank">RubyKaigi 2014: ServerEngine</a> </strong> from <strong><a href="//www.slideshare.net/treasure-data" target="_blank">Treasure Data, Inc.</a></strong> </div></p>

<h2>ServerEngine</h2>

<p><a href="https://github.com/fluent/serverengine">fluent/serverengine</a></p>

<p>ServerEngineはTreasure Dataで開発・運用されている分散キューや分散スケジューラ，それとFluentdなどの経験を元に，汎用的な部分を抽出してフレームワークにしたプロダクトです．発表で言及した機能の他にもBlockingFlagなどのユーティリティがあるので，Rubyでデーモンやバッチワーカーを書くときには是非試して貰えればと思います．</p>

<p>また，FluentdもいずれはServerEngineベースになる予定です．今でもServerEngineと似たような機能を俺俺で実装しているのですが，ServerEngineにすることでよりコードは簡潔に，また新しい機能も実装出来るようになります．この辺は乞うご期待という感じです．</p>

<h2>発表に関して</h2>

<p>1週間前に台北で英語でのキーノートがあり，直前まで時間が取れませんでした．台北後にひたすらスライドを作り，前日にやっと完成という，かなり際どいスケジュール．</p>

<p>本番どうかなと思ったんですが，時間進行を見ながら一部詳細を飛ばしたり，メインホールだったけどそんなに詰まることなく発表出来たんじゃないかなと思います．ここ数年は色々と大きいイベントでの発表も増え，それらの経験のおかげか，日本語であればそれなりにこなせるようになってきたかなと実感してます．</p>

<p>また，Railsとか関係のない，どちらかというと地味というか泥臭い感じの話が多めだったんですが，何人かには受けたようで，良かったです．</p>

<blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/repeatedly">@repeatedly</a> 今年のセッションの中でトップクラスなぐらい良いセッションでした</p>&mdash; 複数DB (@ryopeko) <a href="https://twitter.com/ryopeko/status/512867029565460480">September 19, 2014</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>




<blockquote class="twitter-tweet" data-conversation="none" lang="en"><p><a href="https://twitter.com/repeatedly">@repeatedly</a> よかったですよ！数年前にあれば、あの時苦労しなくてもよかったのに…と思ってしまいました</p>&mdash; Toshiwo (@toshiwo) <a href="https://twitter.com/toshiwo/status/512879201326596097">September 19, 2014</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>




<blockquote class="twitter-tweet" data-conversation="none" lang="en"><p><a href="https://twitter.com/repeatedly">@repeatedly</a> BTW, your talk was great and ServerEngine is cool. Thanks!</p>&mdash; Hiroshi Nakamura (@nahi) <a href="https://twitter.com/nahi/status/513213969855565824">September 20, 2014</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>聞きに来てくれた皆さん，手伝ってくれたスタッフ，そして同時通訳の方々，ありがとうございました！！</p>

<p>とりあえず8月9月のイベントラッシュが終わった感じなので，少しのんびりしたい…んだけど，11月のRubyConfで<a href="http://rubyconf.org/program#prop_569">kiyoto-sanがFluentdについて発表する</a>ようなので，俺も参加しているかもしれません．</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ja/2014/08/yapc-asia-2014/">YAPC::Asia 2014</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-31T11:59:00+09:00" pubdate data-updated="true">Aug 31<span>st</span>, 2014</time>
        
         | <a href="/ja/2014/08/yapc-asia-2014/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://yapcasia.org/2014/">YAPC::Asia 2014</a>に初めて参加した．</p>

<p>Perl使ってないし最初は行く気なかったんだけど，登録中のセッション見るとPerlじゃないの多いし，
個人スポンサーになればTシャツやパーカーも貰えると言うことで，個人スポンサーでチケット入手．</p>

<p>0日目は参加せず，1日目は朝から，2日目は昼から参加．</p>

<h2>1日目</h2>

<h3>完成されたシステムなどない。完成された人間もいない。あるのは成長し続ける未完成なシステムと、それを支える未完成な人間だけだ</h3>

<p>YAPCでのTEDを目指したという発表．大ホールの暗い雰囲気と，宇宙に覆われたスライドによって，
宗教的な感じがしたプレゼン．</p>

<p>発表時間の半分で発表そのものは終わったのだけど，質疑応答をもっと盛り上げれば，完成度は上がったんじゃ無いかと思う．</p>

<h3>お待たせしました。Perl で BDD を簡単に実践する最高にクールなフレームワークができました</h3>

<p>一番Perlっぽい話かな，と思って参加．Perlのテストにおける歴史みたいなのとか，
エコシステムの話みたいなのが聞けたのは面白かった．</p>

<p>「Perl 6と同じくらい夢が詰まっている」という言葉，つらい．</p>

<h3>作られては消えていく、泡のように儚いクラスタの運用話</h3>

<p>TV番組用システムの裏側の話．あるある系もあったり，便利そうなコマンド作ってたり，
なかなかみんな苦労しているな，と．最近TV系の運用話はちょくちょく聞くので，どこも似ている感じ．</p>

<h3>ライブコーディング</h3>

<p>songmuさんともずにおんのコンビ漫才を休憩がてら見ていた．やっぱ本番では色々とミスが起きるｗ</p>

<p>ここで食べたDMMかき氷，普通に美味しかった</p>

<h3>O2O/IoT/Wearable時代におけるWeb以外のネットワーク技術入門</h3>

<p>IoT周辺の技術の用語とか仕組みの説明．いやー，しかしこの辺りは略語が多くてすぐ覚えるのがつらい．</p>

<p>その後はセッションには参加せず，休憩スペースで何人かでISUCONとかPHPとか色々とだべっていた．
MQTT Meetupに参加する予定があったので，懇親会には参加せず会場を去った．</p>

<h2>2日目</h2>

<p>naoyaさんの発表をにやにやしながら見ようかと思っていたのだけど，起きたらもう終わっていたのが心残り．</p>

<p>ついた時間も中途半端だったので，naoyaさんとHUBに行き，そこでmiyagawaさんとかけんじおじさん，shiba_yuさんとかとしゃべっていた．
時間が経つと色々と人が集まってきたのだけど，大ホールの席を取るため移動．</p>

<h3>そんなにビッグでもないデータ処理手法の話</h3>

<p>言うことはないというか，全部知っている話だったので内職をしていた．が，ベストトークで2位だったので，
やっぱ分野が違うと受けるトークも変わるんだなぁという．</p>

<p>ただ，最初にモリスさんがFluentdのユーザを聞いてくれたら半分くらい？は手をあげていたので，
ちゃんと浸透してるんだなと嬉しく思う反面，あと半数にどうやってリーチすべきかというのも考えないと行けない．</p>

<p>モリストリーム…じゃなくてNorikraの宣伝が少なかったな，という印象．</p>

<h3>Lightning Talks Day 2</h3>

<p>席を取っていて良かった，というくらい人がわらわらと集まってきていた．</p>

<p>FluentdがTwitterで非常にアクティブに議論・サポートされている話とか出てきて，Twiterの監視社会怖い!<br />
やっぱLTは短い中にネタを押し込んでくる人が多いので，それ故に面白いのだけど，すぐ終わるのがちょっと悲しい．</p>

<h3>キーノート</h3>

<p>typesterさんのエモい話．typesterさんのキャリアって他の人が真似するのはかなり難しいのだけど，
話の中でも出ていた「複数の人のロールモデルを参考にする」というのに結局落ち着く．</p>

<p>お子さんも一緒に来ていて，ほっこりする感じの発表だった．</p>

<p>あと，typesterさんはIngressは緑のLv8だったので，青のLv8の俺とどこかでやりあってたかも，
と思ったけど鎌倉だし全然関係なかった．</p>

<h3>HUB</h3>

<p>そうそうに一つのビールが無くなっていたけど，ジンジャーエール派の俺には関係なかった．
土曜日は夜に外せない用事があるので，色々な人に絡んでから，早めに帰った．</p>

<h2>改善点</h2>

<p>他の人も書いてると思うけど，意見が多いとそれだけ反映されるだろうということで書いておく．</p>

<h3>キャパシティプランニング</h3>

<p>今年の参加者は約1300人で，それに対して会場のキャパシティは約500人らしく，非常に狭かった．
特に多目的教室は毎度部屋から出るくらいまで立ち見とか出ていたので，ちゃんと聞けない人も多かったのではないかなと．</p>

<p>去年も同じ場所で約1100人だったらしいけど，去年は大丈夫だったのかな？参加してないのでよく分からない．
この辺のマネージは本当に難しいので，一発で解決のアイディアは提示できないのだけども…</p>

<h3>トーク間の移動時間</h3>

<p>2つのトークが続いて休憩がないのがいくつかあって，これは質疑応答と移動時間がかぶってしまうので勿体ないなと．</p>

<h2>まとめ</h2>

<p>トークの種類がPerlに限らず色々とあり，それに伴って参加者も結構多様な感じがしていて楽しかった．
ベストトーク賞のベスト3がどれもPerl関係ないのが，それを物語っていると思う．</p>

<p>ネットワークも快適だったし，休憩スペースも飲み物とかあって，セッション以外でぶらぶらするのも困らなかった．</p>

<p>1000人規模の運営超大変だし，運営チームの方達は本当にお疲れ様でした！来年も楽しみにしてます :)</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ja/2014/08/fluentd-filter-and-label/">Fluentd v0.12でのFilterとLabel</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-25T17:30:00+09:00" pubdate data-updated="true">Aug 25<span>th</span>, 2014</time>
        
         | <a href="/ja/2014/08/fluentd-filter-and-label/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Fluentd，最近だと海外でも露出が増えてきていて，軽量・柔軟・ロバストという所で，
新規の他，既存のログコレクタのリプレース含め，採用する所が増えてたりします．</p>

<p>より改善するため色々とユーザにヒアリングした結果，「フィルタ機能が欲しい」というのが一番多い意見でした．
Fluentdは元々Treasure Dataへロバストにデータを転送するためのミドルウェアで，「ETLとかはTreasure Dataで」
というのもあり，組み込みでフィルタ機能はありませんでした．</p>

<p>今現在のOutputプラグインによるフィルタ実装は，タグの書き換えが必要だったりして少し慣れが必要で，初心者にはちと難しい．
ということで，より簡単に効率よくデータストリームを扱えるフィルタ機能を入れることにしました！</p>

<p>前置きが長くなりましたが，次のバージョンであるv0.12ではFilterとLabelの導入が目玉機能になります．
これらは二つともデータストリームの処理をより楽にするための機能です．</p>

<p>後，<a href="http://www.fluentd.org/blog/fluentd-v0.10.53-is-released">Fluentd v0.10.53のリリースアナウンス</a>でも書きましたが，
今現在のmasterブランチはすでにv0.12用になっています．また，以下の機能はまだmasterにはマージされていません．今週中にはマージ予定ですが，
試して見たい方は，<a href="https://github.com/fluent/fluentd/pull/416">PR #416</a>をチェックしてください．</p>

<h2>Filter</h2>

<p>Outputプラグインで出力する前に，イベント群に処理を適用するための仕組みです．
<code>grep</code>や<code>record_refomer</code>や<code>geoip</code>プラグインなどは，Filterとして実装することでより効率良く処理出来るようになります．</p>

<p>最初に実装，その後に設定の例を見せます．</p>

<h3>実装</h3>

<p>FilterのAPIは以下のようになっています．</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='rb'><span class='line'><span class="k">module</span> <span class="nn">Fluent</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">SomeFilter</span> <span class="o">&lt;</span> <span class="no">Filter</span>
</span><span class='line'>    <span class="no">Plugin</span><span class="o">.</span><span class="n">register_filter</span><span class="p">(</span><span class="s1">&#39;some_filter&#39;</span><span class="p">,</span> <span class="nb">self</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
</span><span class='line'>      <span class="c1"># レコードを弄るプラグインは，ここを実装すればOK</span>
</span><span class='line'>      <span class="c1"># レコードを返す必要がある</span>
</span><span class='line'>      <span class="n">modified_record</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">def</span> <span class="nf">filter_stream</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">es</span><span class="p">)</span>
</span><span class='line'>      <span class="c1"># 以下はFilterのデフォルト実装．grepなどはこちらを置き換えればOK</span>
</span><span class='line'>      <span class="n">new_es</span> <span class="o">=</span> <span class="no">MultiEventStream</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'>      <span class="n">es</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">time</span><span class="p">,</span> <span class="n">record</span><span class="o">|</span>
</span><span class='line'>        <span class="n">new_es</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">filter</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">record</span><span class="p">))</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="n">new_es</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span> <span class="k">if</span> <span class="n">defined?</span><span class="p">(</span><span class="no">Filter</span><span class="p">)</span> <span class="c1"># v0.10とかでエラーにならないための回避策</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h4>filter(tag, time, record)</h4>

<p><code>SetXXXMixin</code>を置き換える<a href="https://gist.github.com/repeatedly/cb16d5667350c8a0e2c9#file-filter_add_metadata-rb">add_metadata</a>フィルタを見て貰えればわかりやすいと思いますが，
引数で渡ってくるレコードを弄って，それを返り値にするだけです<br />
<code>filter</code>とは違い<code>filter_stream</code>は上記のデフォルト実装があるので，変更する必要はありません．</p>

<p>大抵のプラグインはこのAPIをオーバーライドして処理を実装すれば，その結果が次のフィルタに渡されるようになります．</p>

<h4>filter_stream(tag, es)</h4>

<p>EventStreamを直接処理するFilterを書くためのAPIです．例えば<code>grep</code>はレコードを弄らず，EventStream全体に対して処理を行うプラグインなので，
このAPIをオーバーライドします．<code>filter_stream</code>を変更する場合，<code>filter</code>を変更する必要はありません．<br />
<code>filter</code>とは違い，返り値としてEventStreamを返す必要があります．Fluentdは，この<code>filter_stream</code>の返り値を次のFilterに渡し，最終結果をOutputプラグインに渡します．</p>

<p>また，<code>record_reformer</code>の<code>renew_record</code>のように，新しくレコードを生成する系のプラグインもこちら側で処理を実装することになります．
<code>grep</code>と<code>record_reformer</code>のFilter例は以下にあります．</p>

<ul>
<li><a href="https://gist.github.com/repeatedly/0ed3e2b4016b4045640a#file-filter_grep-rb">filter_grep</a></li>
<li><a href="https://gist.github.com/repeatedly/5c9f89e14aace5cda195#file-filter_record_reformer-rb">filter_record_reformer</a></li>
</ul>


<h3>設定</h3>

<p><code>&lt;filter&gt;</code>セクションが追加されています．たとえば，<code>add_metadata</code>と<code>grep</code>を使う場合には以下のようになります．</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='aconf'><span class='line'><span class="nt">&lt;source&gt;</span>
</span><span class='line'>  <span class="nb">type</span> forward
</span><span class='line'><span class="nt">&lt;/source&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;filter&gt;</span> <span class="c"># &lt;filter&gt;と&lt;filter **&gt;は同じ</span>
</span><span class='line'>  <span class="nb">type</span> grep
</span><span class='line'>  <span class="err">input_</span><span class="nb">key</span> message
</span><span class='line'>  <span class="nb">regexp</span> <span class="k">WARN</span>
</span><span class='line'><span class="nt">&lt;/filter&gt;</span>
</span><span class='line'><span class="nt">&lt;filter&gt;</span>
</span><span class='line'>  <span class="nb">type</span> add_metadata
</span><span class='line'>  <span class="err">include_tag_</span><span class="nb">key</span>
</span><span class='line'>&lt;/filter&gt;
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;match</span> <span class="s">**</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nb">type</span> stdout
</span><span class='line'><span class="nt">&lt;/match&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fluentdの設定ファイルの流儀にしたがって，上から順番に<code>match</code>にマッチしたところまでのFilterが適用されます．
この例では，まず<code>grep</code>が適用され，その次に<code>add_metadata</code>，そしてこれらの結果のEventStreamが<code>stdout</code>に渡されます．<br />
例えば以下のデータが入ってきたとして:</p>

<pre><code>{"message":"INFO"}
{"message":"WARN"}
</code></pre>

<p><code>stdout</code>には，<code>grep</code>で最初のレコードがフィルタリングされ，<code>add_metadata</code>でタグが追加された以下のデータが渡されます:</p>

<pre><code>{"message":"WARN", "tag":"filter.test"}
</code></pre>

<p>タグを書き換えて<code>match</code>の条件を調整して〜という煩わしさから解放されるようになります．</p>

<p>注意点としては，マッチした<code>match</code>の下にある<code>filter</code>は，たとえtagがマッチしようが適用されない所です．</p>

<h3>パフォーマンス</h3>

<p>タグの書き換えや再emitが発生しないため，速度やメモリ効率は多少よくなるはずです．</p>

<p>手元で約450MBのファイルを<code>in_tail</code>で読み込み，<code>record_reformer</code>でホスト名などを付加して転送する，
というのをv0.10とv0.12で測ってみた所，v0.10は181秒，v0.12は149秒で，約30秒短縮されました．</p>

<p>ユーザによってはもっとFilterがチェーンしている所もあるはずなので，そういう場合には恩恵が大きいと思います．</p>

<h2>Label</h2>

<p>これはFilterやOutputをまとめるための機能になります．制限として，InputはLabelの中に含めることは出来ません．
こちらは先に設定から見てみます．</p>

<h3>設定</h3>

<p>以下が簡単な例になります．</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='aconf'><span class='line'><span class="nt">&lt;source&gt;</span>
</span><span class='line'>  <span class="nb">type</span> forward
</span><span class='line'>  <span class="err">@</span><span class="nb">label</span> @forward
</span><span class='line'><span class="nt">&lt;/source&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;source&gt;</span>
</span><span class='line'>  <span class="nb">type</span> tail
</span><span class='line'>  <span class="nb">path</span> <span class="sx">/path/to/file</span>
</span><span class='line'>  <span class="nb">tag</span> tail
</span><span class='line'><span class="nt">&lt;/source&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;filter</span> <span class="s">**</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nb">type</span> grep
</span><span class='line'>  <span class="c"># ...</span>
</span><span class='line'><span class="nt">&lt;/filter&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;match</span> <span class="s">**</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nb">type</span> mongo
</span><span class='line'>  <span class="c"># ...</span>
</span><span class='line'><span class="nt">&lt;/match&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;label</span> <span class="s">@forward</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;filter</span> <span class="s">**</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nb">type</span> add_metadata
</span><span class='line'>    <span class="err">include_tag_</span><span class="nb">key</span>
</span><span class='line'>  &lt;/filter&gt;
</span><span class='line'>  <span class="nt">&lt;match</span> <span class="s">**</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nb">type</span> file
</span><span class='line'>  <span class="nt">&lt;/match&gt;</span>
</span><span class='line'><span class="nt">&lt;/label&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>forward</code>の中に<code>@label @forward</code>というパラメータがあります．これがLabelの指定になっていて，
<code>@label</code>があるとその指定されたLabelにイベント群が流れて行きます．なので，この例では<code>forward</code>で
受け付けたイベント群は，<code>add_metadata</code>フィルタを通り，その下の<code>file</code>に到達します．<br />
一方，<code>@label</code>のないInputは今までと同じ挙動となり，トップにイベント群を流します．
この例では，<code>grep</code>フィルタを通り，その下の<code>mongo</code>に到達します．</p>

<p>Labelの機能によって，各プラグイン間の関係がわかりやすくなり，またルーティングのためにタグを調整する必要もなくなります．
<code>out_relabel</code>プラグインを使えばデータを別のLabelに飛ばせるので，入力によって違うフィルタを適用したいが，書き込み先は一緒にしたい，
みたいな処理も簡単にできるようになります．</p>

<h3>実装</h3>

<p>v0.12から，<code>router</code>というのがInput/Outputに増えてます．今まで<code>Engine.emit</code>と書いていた所を，<code>router.emit</code>に書き換えるだけで，
Labelの機能が使えるようになります．<br />
言い換えれば，この書き換えをしていないInput/Outputプラグインは，<code>@label</code>が使えないということになります．</p>

<h2>まとめ</h2>

<p>v0.12の主要機能であるFilterとLabelについて簡単に説明しました．まだ実装としていくつか細かな改善はあるのですが，
基本機能は上記のままで行くと思います．<br />
何かフィードバックがあれば<code>@repeatedly</code>にmentionをするか，上記の該当PRにコメントをして貰えればと思います．</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ja/2014/08/fluentd-ui/">Fluentd UI</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-04T04:10:00+09:00" pubdate data-updated="true">Aug 4<span>th</span>, 2014</time>
        
         | <a href="/ja/2014/08/fluentd-ui/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="https://github.com/fluent/fluentd-ui">fluent/fluentd-ui</a></p>

<p><img src="/images/fluentd_ui_ss.png" title="&#34;Fluentd UI image&#34;" alt="&#34;Fluentd UI image&#34;"></p>

<p>Fluentdのエコシステムの一つとして，Fluentd UIをリリースしました．
すでに試してくれたユーザもいるようなので，現在の使用感などは下記の記事を参考にしてください．</p>

<ul>
<li><a href="http://suzuken.hatenablog.jp/entry/2014/08/01/202334">Fluentd UIが出たので触ってみた</a></li>
<li><a href="http://qiita.com/inokappa/items/0a4a2db7abad22458bea">Touch the fluentd-ui(1)</a></li>
</ul>


<p>この記事ではFluentd UIそのものについてつらつらと書きたいと思います．英語でのアナウンスもいずれ公式ブログに載るはず．</p>

<h2>Fluentd UIの生い立ち</h2>

<p>Fluentd UIの背景として，Fluentdも最近は国を問わず色々な所でユーザが増えてきており，
「CLIとか楽勝！」以外のユーザの割合も増えつつあります．</p>

<p>ログコレクタでリッチな管理UIを持っているプロダクトってほとんどないと思うのですが，
新しく使い始めるユーザの嵌まり所とか見ていると，
GUIの方が始めるための敷居が下がりそうなポイントがいくつかありました．</p>

<p>なので，Fluentdを使いたい人がなるべく嵌まらずに始められるようにと，
万葉の方と開発したのがFluentd UIです．</p>

<h2>Fluentd UIのコンセプト</h2>

<p>生い立ちの所で書いた通り，Fluentdの敷居を下げるのが第一の目的なので，
すでにFluentdをバリバリ使っている人はユーザの対象ではありません．</p>

<p>バージョン0.1.0の段階で，以下の機能があります:</p>

<ul>
<li>Fluentdのプロセスの管理 (start/stop/restart)</li>
<li>Fluentdの設定ファイルの管理と編集</li>
<li>Fluentdのプラグインの管理 (install/uninstall/update)</li>
<li>ログやシステム情報のビューワー，などなど</li>
</ul>


<p>最初に色々機能を洗い出したのですが，全部入れるとリリースが遅れるし，
複雑なのを入れるとユーザが混乱するかもということで，ベーシックな機能セットに絞りました．<br />
それでも，プラグイン入れての挙動チェックなど，全部Webから出来るようになっています．また，
ユーザがテストしにくかったin_tailは，<a href="http://fluentular.herokuapp.com/">Fluentular</a>を参考にかなり使いやすいUIになったと思います．</p>

<p>実装的にもかなり依存を減らしていて，例えば，最初はSQLiteベースだったのですが，
「SQLiteだとFluentd UIそのもののセットアップに嵌まる人が出る可能性がある」とファイルベースに変更したりしました．</p>

<h2>Fluentd UIの今後の展望</h2>

<h3>機能追加</h3>

<p>バージョン0.1.0ということから分かる通り，まだまだ始まったばかりのプロダクトで，
今回は開発者側が「こういう機能があったら始めやすいだろう」というものを中心に入れました．<br />
今後はユーザからのフィードバックも受けつつ，更に使いやすさを改善して行けたらなと．</p>

<p>現状各プラグインの設定を削除する時は，自分でフリーフォームから消す必要があるので，
この辺もボタンで消せるようにとか，出来たらいいかなぁと考えてます．<br />
あと，今設定が組み込みで実装してあるので(インストールした3rd partyプラグイン用の設定ページがない)，
各プラグインから自動で設定ページが生成できるような仕組みも必要かなと，色々と模索中です．</p>

<h3>td-agent 2への同梱</h3>

<p>td-agentには同梱予定はないんですが，td-agent 2にはtd-agent-uiみたいな感じで同梱する予定です．すでに起動した人は知っていると思いますが，td-agentをセットアップする用のボタンがあります :)</p>

<h3>他の環境との連携</h3>

<p>Fluentd UIは，UI上で色々と試行錯誤しその結果出来た設定ファイルをChefとかで配布，
みたいなのを想定しているのですが，毎回コピペとか面倒ですし，
最近だと<a href="https://github.com/sonots/fluentd-server">fluentd-server</a>とかもあるので，この辺なんか上手くやりたいな，と．</p>

<h2>まとめ</h2>

<p>Fluentd UIについて背景含めつらつらと書きました．是非試して頂いて，問題があったら<a href="https://github.com/fluent/fluentd-ui/issues">issue</a>投げるなり<a href="https://github.com/fluent/fluentd-ui/pulls">PR</a>なりしてもらえると助かります！</p>

<p>あ，ちなみに最初のリリースは俺がやりましたが，開発はコミットを見れば分かる通り<a href="https://github.com/uu59">uu59</a>さんでちゃんとしたRailsコードになっているので，ご心配なく！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/ja/2014/07/fluentd-and-log-forwarding-patterns/">Fluentdとログ収集のパターン</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-31T18:35:00+09:00" pubdate data-updated="true">Jul 31<span>st</span>, 2014</time>
        
         | <a href="/ja/2014/07/fluentd-and-log-forwarding-patterns/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>「ログを集めて保存する」と言うのは簡単だけど，ログ収集の構成にはいくつか方法があり，勉強会などでちょくちょく聞かれるので，いくつかのパターンについて書く．<br />
「俺はもうバリバリログ収集やってるぜ！」という人は多分すでに知っていることが書かれているので，タブを閉じて良い．</p>

<p>ここではログコレクタにFluentdを想定しているが，他のログ収集プロダクトにも適用出来るはず．
ただ，Fluentdはタグベースのルーティングを持ち，単体でもキューのように動作させることが可能で，既存のものより複雑な問題を解決しようとしているので，少し工夫が必要かもしれない．<br />
Fluentdそのものについては<a href="http://docs.fluentd.org/articles/quickstart">公式ドキュメント</a>や，<a href="http://tagomoris.hatenablog.com/entry/2013/12/03/150656">Fluentdとはどのようなソフトウェアなのか</a>を参考に．</p>

<h2>クライアントから直接保存する</h2>

<p><img src="/images/fluentd_only_client_pattern.png" title="&#34;Only client pattern&#34;" alt="&#34;Only client pattern&#34;"></p>

<p>いきなりFluentdを使わないパターン．JavaScript SDKを提供している解析サービスやモバイル端末などでよく使われている．ログがユーザサイドで発生する場合にはログコレクタを仕込むことは出来ないので，基本このアプローチになる．<br />
これらはクライアントの出来によって精度が左右されるが，モバイルであれば繋がらなかったら一定量バッファリングをし，ネットワークが繋がった段階で非同期に転送などがよくある実装．</p>

<p>ログコレクタを用意出来るサーバサイドでこのアプローチを取っているシステムは最近だとあまり聞かない．もしやるならエラーハンドリングとして</p>

<ul>
<li>バッファリング</li>
<li>リトライ</li>
<li>ロードバランシング</li>
</ul>


<p>などの問題を解決する必要がある．Fluentdであればこれらの機能が最初からついているので，今から構築するシステムでやる必要はほとんど無いと思われる．</p>

<h2>末端ノードのログコレクタから直接保存する</h2>

<p><img src="/images/fluentd_only_leaf_node_pattern.png" title="&#34;Only leaf node pattern&#34;" alt="&#34;Only leaf node pattern&#34;"></p>

<p>アプリケーションやノードからログを集め，ログコレクタから直接保存する．「クライアントから直接保存する」の例で，ローカルにログコレクタを置き，そこ経由でデータを投げつけるモデル．<br />
ネットワーク周りのややこしい問題をログコレクタに任せられ，Fluentdであればプラグインで容易にストリームを操作できるのがメリット．また，ApacheやNginxから直接外部にデータを投げるのは難しいので，Fluentdでファイルにはき出されたログを収集するときにはこの構成となる．</p>

<p>この構成だと，収集対象のサーバが多くなるだけアクセスが増えて保存先への負荷があがるので</p>

<ul>
<li>データのストリームがそれほど大きくない</li>
<li>保存先が書き込みに対して耐性がある (クラウドサービスなど)</li>
</ul>


<p>などの場合に有効になる．次で書く集約ノードが必要ないので，その分管理は楽になる．<br />
Fluentdは転送役と集約役に違いはないので，この段階でフィルター系プラグインを使って，データを加工することもある．</p>

<p><a href="http://www.treasuredata.com/">Treasure Data</a>の場合には，<a href="https://metrics.librato.com/">Librato Metrics</a>に投げる所などは集約ノードを経由せず，各Fluentd(Treasure Agent)から直接投げている．この場合は各ノードのメトリックスが取りたいので，集約ノードでデータストリームをまとめる必要もない．</p>

<p>これとは違いMongoDBの場合だと，細かいのをちまちま送るより大きめのバッチでガンと書き込んだ方が効率が良いので，このモデルよりも集約ノードを置いた方が良い．</p>

<h2>集約ノードのログコレクタを経由して保存する</h2>

<p><img src="/images/fluentd_aggregation_node_pattern.png" title="&#34;Using aggregation node pattern&#34;" alt="&#34;Using aggregation node pattern&#34;"></p>

<p>ログコレクタでの多段構成モデル．集約ノードを置く利点は，データストリームをまとめてデータに対する処理をしやすくする点が大きい．また，各ノードから集めることでストリームが太くなり，マイクロバッチの効率も良くなる．</p>

<p>Fluentdでもアグリゲーションをしたり，<a href="http://norikra.github.io/">Norikra</a>と連携するプラグインがあったりするので，その手の処理はこの集約ノードでやるのがベター．</p>

<p>大抵のログコレクタと同じく，Fluentdのデフォルトの転送プロトコルはPush型になっていて，多段構成時には流れるように保存先にデータが集まるようになっている．<br />
多段構成時の注意点は，ある場所のノードが落ちた時にストリームが途切れてしまう所．Fluentdの場合は障害に対応するために，転送先を複数指定可能で，その中で負荷分散とノードが落ちた時の処理を指定出来るようになっていて，よほど一気にノードが落ちない限りストリームが途切れることはない．もし落ちてもバッファリングが行われるので，ノードを再度立ち上げればデータはまた流れ出す．</p>

<h3>PaaS上でのアプリケーション</h3>

<p>アプリケーションをホストするような環境だとローカルにFluentdを置けなかったりするので(HerokuだとFluentdは起動できるが，ファイルバッファが使えなかったりする．ユースケース次第)，その場合はいきなり集約ノードやキューにデータを投げることになる．</p>

<h2>キューを置く</h2>

<p><img src="/images/fluentd_queue_pattern.png" title="&#34;Using queue pattern&#34;" alt="&#34;Using queue pattern&#34;"></p>

<p>データストリームの中でキューを間に挟むことの主な理由は，ログのreliabilityの向上と，処理の間にワンクッション置くこと．</p>

<p>そもそもキューはPush型ではなくPull型であり，Producer・Queue・Consumerと登場人物も増えるので，キューを置くことでログ収集そのものが効率化されることはあまりない．異なる粒度のシステム間で連携をする時に，間にキューを置くことが多い．</p>

<p>実際Fluentdとキューを連携させている例はいくつかあり，たとえば複雑なシステムを構築している<a href="http://engineering.viki.com/blog/2014/data-warehouse-and-analytics-infrastructure-at-viki/">Vikiの例</a>ではKestrelでFluentdからのデータストリームを分岐させているし，AWSは本家が<a href="https://github.com/awslabs/aws-fluent-plugin-kinesis">fluent-plugin-kinesis</a>を書いているので，いずれこの事例も増えるはず.</p>

<p>KafkaやKinesisなど信頼性のあるキューを間に置けば，ログをそれなりの期間保持しつつ，Consumerを複数用意することでストリームを分岐できる．<br />
Push型での分岐とは違い，キューからログを取る側の都合でデータを処理出来るので，各データストリームで処理粒度が違う時に有効．
ただ，キューそのものに信頼性があってもProducer/Consumerが駄目だと効率が良くならずログが欠損/重複するので，自分たちのシステム要件に合わせてちゃんと構築する必要がある．</p>

<h3>Pull型のログ収集</h3>

<p>キューを置かずにPull型でログを転送する方法もある．Kafkaほどの信頼性を期待するのは難しいが，Pull型の利点を享受できる．まだ完成していないが，Fluentdだとモリス=タゴという人が，<a href="https://github.com/tagomoris/fluent-plugin-pullforward">pullforward</a>というのを開発中らしい．</p>

<h2>Fluentdを使わない方が良いパターン</h2>

<p>プロダクションで使われているパターンをいくつか書いた．大抵のシステムは上のどれかの構成に当てはまる．FluentdはWebや広告のみならずIoTやPOS含め色々なところで使われていて，データのアーカイブ，簡単なストリーム処理，ノードやアプリケーションのモニタリング，などなど様々なユースケースの基盤になれる柔軟性がある．</p>

<p>また，LINE社で2年間問題なく動いているし，最近勉強会とかで話を聞くと「安定していて自分の仕事がない」と言われる位，よほど変なことしない限り安定性もある．ある会社で100億events/dayをFluentdクラスタで転送した実績もあるので，パフォーマンスもそれなりにある(フィルタ的な処理を重ねまくると，もちろん遅くなる)．</p>

<p>が，Fluentdを使わない方が良いケースもある．以下主に二つ．</p>

<h3>Exactly Onceが必要なケース</h3>

<p>一切ログの欠損も重複も許せない，しかも確実に書き込む必要がある，というケース．<br />
ストリーム処理でExactly Onceを保証するのはかなり難しく，俺が知っている限りOSSでは存在していない．商用でもほとんど知らない．</p>

<p>Exactly Onceを実現しようとすると，ログ発生時点から書き込むまでを完全に同期的にやるか，様々な箇所でトランザクションが必要になり，スケールアウトが難しくコストもものすごく掛かる．そして保存先にもそれなりの機能が求められる．</p>

<p>かつてOSSでマスターノードを使い到達保証を目指したプロダクトがあったが，結局パフォーマンスがボトルネックになり，そこまでしてもログの欠損が防げなかったため，新しいバージョンでは諦めることになった．</p>

<h4>Fluentdのモデル</h4>

<p>FluentdはAt Most Onceであり，<a href="http://docs.fluentd.org/articles/high-availability">ドキュメントにもモデルの説明と対策が書いてある</a>，<br />
これはログが欠損/重複しまくるということではなく，At Most OnceもAt Least Onceも通常は問題は起きない．トポロジーに問題がある場合に，システム的に欠損/重複が起きうるという話．そして大抵のユーザはExactly Onceでなくても上手く行く．</p>

<p>Fluentdでも欠損/重複を防ぐための対策はいくつかあり</p>

<ul>
<li>ログにユニークIDを足して，HadoopなどのETLで重複を削除する</li>
<li>直近の生ログは保持しておき，保存先とのレコード数を比較する．おかしい所は再送</li>
<li>データストリームを複数作って冗長性を持たせる</li>
</ul>


<p>などなど．システム的にExactly Onceではなくても，それに低コストで近づけることは可能．</p>

<h3>データストリームが一本で密結合したサービスがある</h3>

<p>たとえばAWSのCloudWatch Logsがそう．Agentのセットアップが必要だったりして楽かと言われるとまだ微妙だが，今後最初からインストールされる可能性もある．<br />
そのような状況で，Agentから取れるログをCloudWatch Logsで直接見るので十分であれば，Fluentdを入れるメリットは少ない(<a href="https://github.com/ryotarai/fluent-plugin-cloudwatch-logs">CloudWatch Logs</a>用のプラグインがあるので，Fluentdから利用することは可能)．</p>

<p>Fluentdの利点は簡単にロバストで柔軟性のあるログ収集基盤が作れて，一度構築してしまえば，環境非依存でそのログ収集基盤を再利用出来るところなので，そのような必要性がないのであれば，環境と密結合したサービスを使う方が運用コストそのものは直近は削減できるはず．</p>

<h2>まとめ</h2>

<p>Fluentdが向いているケースと向いてないケース，そのPros/Consみたいなのを書いた．細かく書けばもっと色々と書けるのだけど，記事でそんなに長々と書いても疲れるだけなので大まかに．
何か質問があればTwitterで<a href="https://twitter.com/repeatedly">@repeatedly</a>にmentionするなり，この記事にコメントするなりしてください :)</p>

<p>もうすぐFluentd + Elasticsearch + Kibanaという有名な構成のムック本が出るようなので，この本とか読むと，解析のノウハウ含め色々とここには書いていない情報が手に入るのではないかと思います．<br />
<a href="http://www.amazon.co.jp/exec/obidos/ASIN/4774169838/repeatedly-22/ref=nosim/"><img src="http://ecx.images-amazon.com/images/I/61vwvFp6EEL._SL160_.jpg" /></a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/ja/page/2/">&larr; Older</a>
    
    <a href="/archives">Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/ja/2014/09/serverengine-at-rubykaigi-2014/">ServerEngine at RubyKaigi 2014</a>
      </li>
    
      <li class="post">
        <a href="/ja/2014/08/yapc-asia-2014/">YAPC::Asia 2014</a>
      </li>
    
      <li class="post">
        <a href="/ja/2014/08/fluentd-filter-and-label/">Fluentd v0.12でのFilterとLabel</a>
      </li>
    
      <li class="post">
        <a href="/ja/2014/08/fluentd-ui/">Fluentd UI</a>
      </li>
    
      <li class="post">
        <a href="/ja/2014/07/fluentd-and-log-forwarding-patterns/">Fluentdとログ収集のパターン</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>Github Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/repeatedly">@repeatedly</a> on Github
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'repeatedly',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("repeatedly", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/repeatedly" class="twitter-follow-button" data-show-count="false">Follow @repeatedly</a>
  
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Masahiro Nakagawa -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'repeatedly';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
